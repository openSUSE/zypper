//
// Copyright (c) 2006 Alexis Wilke
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Find documentation on the home website:
//
//	http://boost-extras.sourceforge.net/
//	http://boost-extras.sourceforge.net/ini_file/ini_file.html
//
#ifndef BOOST_EXTRAS_INI_FILE
#define	BOOST_EXTRAS_INI_FILE 1

#include	<boost/shared_ptr.hpp>
#include	<exception>
#include	<string>
#include	<map>
#include	<iostream>

namespace ini_file
{


namespace ini_exceptions
{
	class ini_file_exception    : std::exception {};
	class section_name_missing  : ini_file_exception {};
	class invalid_section_name  : ini_file_exception {};
	class param_name_missing    : ini_file_exception {};
	class invalid_param_name    : ini_file_exception {};
	class invalid_parameter     : ini_file_exception {};
	class param_without_section : ini_file_exception {};
	class invalid_quotation     : ini_file_exception {};
}		// namespace ini_exceptions


namespace details
{
struct name
{
	name(const std::string& _name) : m_name(_name) {}
	virtual ~name() {}
	//void set_name(const std::string& _name) { m_name = _name; }
	const std::string& get_name() const { return m_name; }

private:
	const std::string m_name;
};
extern std::ostream& operator << (std::ostream& out, const name& _name);
struct comment
{
	virtual ~comment() {}
	void set_comment(const std::string& _comment) { m_comment = _comment; }
	const std::string& get_comment() const { return m_comment; }

private:
	std::string m_comment;
};
extern std::ostream& operator << (std::ostream& out, const comment& _comment);
}		// namespace details


struct param : details::name, details::comment
{
	param(const std::string& _name) : details::name(_name) {}
	void set_value(const std::string& _value) { m_value = _value; }
	const std::string& get_value() const { return m_value; }

	param& operator = (const std::string& _value) { set_value(_value); return *this; }
	operator const std::string& () const { return m_value; }
private:
	std::string m_value;
};
namespace details
{
typedef std::map<std::string, boost::shared_ptr<param> > param_map_t;
}
struct param_map : details::param_map_t
{
	void insert(boost::shared_ptr<param> _p)
		{
		  if(_p) {
			details::param_map_t::insert(details::param_map_t::value_type(_p->get_name(), _p));
		  }
		}
	param& operator [] (const std::string& _name)
		{
		  details::param_map_t::iterator i = details::param_map_t::find(_name);
		  if(i == end()) {
			boost::shared_ptr<param> p(new param(_name));
			insert(p);
			return *p;
		  }
		  return *i->second;
		}
	const param& operator [] (const std::string& _name) const
		{
		  details::param_map_t::const_iterator i = details::param_map_t::find(_name);
		  if(i == end()) return m_empty;
		  return *i->second;
		}

private:
	static const param m_empty;
};



struct section : details::name, details::comment, param_map
{
	section(const std::string& _name) : details::name(_name) {}
};
namespace details
{
typedef std::map<std::string, boost::shared_ptr<section> > section_map_t;
}
struct section_map : details::section_map_t
{
	void insert(boost::shared_ptr<section> _s)
		{
		  if(_s) {
			details::section_map_t::insert(details::section_map_t::value_type(_s->get_name(), _s));
		  }
		}
	const section& operator [] (const std::string& _name) const
		{
		  details::section_map_t::const_iterator i = details::section_map_t::find(_name);
		  if(i == end()) return m_empty;
		  return *i->second;
		}
	section& operator [] (const std::string& _name)
		{
		  details::section_map_t::iterator i = details::section_map_t::find(_name);
		  if(i == end()) {
			boost::shared_ptr<section> s(new section(_name));
			insert(s);
			return *s;
		  }
		  return *i->second;
		}
private:
	static const section m_empty;
};





extern std::istream& operator >> (std::istream& in, section_map& _section_map);

extern std::ostream& operator << (std::ostream& out, const param& _param);
extern std::ostream& operator << (std::ostream& out, const section& _section);

extern std::ostream& operator << (std::ostream& out, const param_map& _param_map);
extern std::ostream& operator << (std::ostream& out, const section_map& _section_map);



}	// namespace ini_file


#endif // #ifdef BOOST_EXTRAS_INI_FILE
// vim: ts=4
